<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Small Support Game (LittleJS)</title>
  <style>
    /* Make the canvas fill the window and remove default margins */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
    }
  </style>
</head>
<body>
  <!-- Load LittleJS from jsDelivr CDN -->
  <script src="https://cdn.jsdelivr.net/npm/littlejsengine@1.14.9/dist/littlejs.min.js"></script>
  <script>
    // Simple prototype for the "Small Talk Support" game.
    // The goal is to resolve humorous IT calls by picking the right response.
    // This demo shows how to use LittleJS for UI-based interaction without any
    // external assets. It focuses on text, mouse input, and simple scoring.

    'use strict';

    // Pre‑define a few silly calls; each has a message and possible responses.
    const calls = [
      {
        message: "Caller: My desktop icons are so small I need a microscope! What do I do?",
        options: [
          { text: "Guide them to press Ctrl + Plus to zoom in", correct: true },
          { text: "Suggest buying a bigger monitor", correct: false },
          { text: "Tell them to restart their computer", correct: false }
        ],
      },
      {
        message: "Caller: The text on my screen is miniature. I swear it shrunk overnight!",
        options: [
          { text: "Explain how to adjust display scaling settings", correct: true },
          { text: "Advise them to squint harder", correct: false },
          { text: "Tell them it’s a virus and they’re doomed", correct: false }
        ],
      },
      {
        message: "Caller: The USB port is too small for my cable — can you please enlarge it?",
        options: [
          { text: "Suggest flipping the cable and gently inserting it", correct: true },
          { text: "Recommend using a hammer to widen the port", correct: false },
          { text: "Tell them to call a carpenter", correct: false }
        ],
      }
    ];

    let currentIndex = 0;
    let score = 0;
    let ended = false;

    // Audio: simple click sound for feedback
    const soundClick = new Sound([1, 0.5]);

    // Move to next call or finish
    function nextCall() {
      currentIndex++;
      if (currentIndex >= calls.length) {
        ended = true;
      }
    }

    // Required by LittleJS — called once on startup.
    function gameInit() {
      // Optional: adjust camera scale so coordinates roughly match pixel values.
      // Without this, world coordinates are used; we stick to screen space for UI.
      // Hide splash screen for a cleaner experience.
      setShowSplashScreen(false);
    }

    // Handle input. Check for mouse clicks on option boxes.
    function gameUpdate() {
      if (ended) return;

      // React to left mouse button press
      if (mouseWasPressed(0)) {
        // Screen coordinates of the click
        const m = mousePosScreen;
        if (!m.x) return;
        const call = calls[currentIndex];

        // Compute bounding boxes for each option. Buttons are centered horizontally.
        const marginTop = 180;
        const buttonHeight = 50;
        const buttonSpacing = 10;
        const buttonWidth = Math.min(mainCanvasSize.x - 80, 600);

        for (let i = 0; i < call.options.length; i++) {
          // Y position from top; invert y since screen origin is top left for UI
          const y = marginTop + i * (buttonHeight + buttonSpacing);
          const x = (mainCanvasSize.x - buttonWidth) / 2;

          // Check if mouse is inside this button
          if (m.x >= x && m.x <= x + buttonWidth && m.y >= y && m.y <= y + buttonHeight) {
            const opt = call.options[i];
            // Play feedback sound
            soundClick.play(m);
            if (opt.correct) {
              score++;
            }
            nextCall();
            break;
          }
        }
      }
    }

    // Render the current game state
    function gameRender() {
      // Clear background
      drawRectScreen(vec2(mainCanvasSize.x / 2, mainCanvasSize.y / 2), vec2(mainCanvasSize.x, mainCanvasSize.y), '#1e1e1e');

      if (!ended) {
        const call = calls[currentIndex];

        // Draw call header and message
        drawTextScreen(`Call ${currentIndex + 1} of ${calls.length}`, vec2(mainCanvasSize.x / 2, 40), 24, '#ffffff', 1, '#000000', 1, 0, 'center');

        // Wrap long messages manually by splitting on \n or using multiple draw calls. For brevity, message lines are limited.
        drawTextScreen(call.message, vec2(mainCanvasSize.x / 2, 90), 20, '#ffc107', 1, '#000000', 1, 0, 'center');

        // Draw buttons
        const marginTop = 180;
        const buttonHeight = 50;
        const buttonSpacing = 10;
        const buttonWidth = Math.min(mainCanvasSize.x - 80, 600);

        for (let i = 0; i < call.options.length; i++) {
          const y = marginTop + i * (buttonHeight + buttonSpacing);
          const x = (mainCanvasSize.x - buttonWidth) / 2;

          // Button background
          const bgColor = '#61dafb';
          drawRectScreen(vec2(x + buttonWidth / 2, y + buttonHeight / 2), vec2(buttonWidth, buttonHeight), bgColor);

          // Button text
          drawTextScreen(call.options[i].text, vec2(x + buttonWidth / 2, y + buttonHeight / 2 + 6), 18, '#000000', 0, '#ffffff', 1, 0, 'center');
        }

        // Score display
        drawTextScreen(`Score: ${score}`, vec2(mainCanvasSize.x - 20, mainCanvasSize.y - 20), 18, '#ffffff', 0, null, 1, 0, 'right');
      } else {
        // End screen
        drawTextScreen('All calls resolved!', vec2(mainCanvasSize.x / 2, mainCanvasSize.y / 2 - 20), 28, '#00ff88', 1, '#000000', 2, 0, 'center');
        drawTextScreen(`Final Score: ${score} / ${calls.length}`, vec2(mainCanvasSize.x / 2, mainCanvasSize.y / 2 + 20), 22, '#ffffff', 0, '#000000', 1, 0, 'center');
        drawTextScreen('Refresh page to play again.', vec2(mainCanvasSize.x / 2, mainCanvasSize.y / 2 + 60), 16, '#aaaaaa', 0, null, 1, 0, 'center');
      }
    }

    // Unused hooks – defined for completeness
    function gameUpdatePost() {}
    function gameRenderPost() {}

    // Initialize the engine. The order of functions is important.
    engineInit(gameInit, gameUpdate, gameUpdatePost, gameRender, gameRenderPost);
  </script>
</body>
</html>
